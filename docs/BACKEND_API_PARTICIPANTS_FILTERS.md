# API участников — фильтры по категориям и сетам

Чтобы фильтры в экране «Список участников» работали, эндпоинт `/api/participants` должен возвращать определённые поля. Сейчас фильтры по категории и по сетам не работают, если бэкенд их не отдаёт или отдаёт в другом формате.

---

## Эндпоинт

```
GET /api/participants?event_id={event_id}
```

Заголовки: `Accept: application/json`, опционально `Authorization: Bearer {token}`.

---

## Требуемые поля в каждом элементе ответа

Ответ — массив объектов. Каждый объект (участник) должен содержать:

### 1. `category` (обязательно для фильтра по категории)

**Тип:** строка.

**Важно:** Значение должно **точно совпадать** со строкой `category` из списка категорий события (из эндпоинта деталей соревнования).

Примеры корректных значений:
- `"1 группа (2011-2010)"`
- `"2 группа (2009-2008)"`
- `"Мужчины"`

**Частые ошибки:**
- Бэкенд отдаёт `participant_category` (объект) вместо плоского `category` — Flutter ожидает `category` на верхнем уровне.
- Бэкенд отдаёт только `category_id` — нужно также вернуть строку `category` для отображения и фильтрации.
- Формат строки отличается от того, что в событии (лишние пробелы, другой регистр и т.п.) — сравнение будет по точному совпадению после `trim()`.

**Рекомендуемая реализация:** при формировании ответа брать строку категории из той же таблицы/модели, что и в ответе события (например, из связи `participant -> category -> category`).

---

### 2. `number_set` / `number_sets` / `set` / `sets` (обязательно для фильтра по сетам)

**Тип:** один из вариантов:

| Поле          | Тип        | Пример     | Описание                      |
|---------------|-------------|------------|-------------------------------|
| `number_set`  | int         | `1`        | Один сет                      |
| `number_sets` | массив int  | `[1, 2]`   | Несколько сетов              |
| `set`         | int/string  | `1` или `"1"` | Альтернативное имя поля  |
| `sets`        | int/string/массив | `1` или `[1,2]` | Альтернативное имя поля |

Flutter читает в таком порядке: `number_sets` → `number_set` → `set` → `sets`.

**Если сеты не используются** (в соревновании один сет или `is_input_set == 1`): поле можно не передавать. Тогда фильтр по сетам в UI не показывается.

**Если сеты используются:** для каждого участника нужно передать номер(а) сета(ов), в которых он участвует. Номер должен совпадать с `number_set` из списка сетов события.

---

### 3. Остальные поля (для отображения)

| Поле        | Тип   | Описание                    |
|-------------|-------|-----------------------------|
| `middlename`| string| ФИО (имя и фамилия)         |
| `city`      | string| Город                       |
| `gender`    | string| Пол                         |
| `birthday`  | string| Дата рождения               |
| `user_id` или `id` | int | ID пользователя (для перехода в профиль) |

---

## Пример корректного ответа

```json
[
  {
    "user_id": 123,
    "middlename": "Иванов Иван",
    "city": "Москва",
    "category": "1 группа (2011-2010)",
    "gender": "male",
    "birthday": "2011-05-15",
    "number_set": 1
  },
  {
    "user_id": 456,
    "middlename": "Петрова Анна",
    "city": "Санкт-Петербург",
    "category": "2 группа (2009-2008)",
    "gender": "female",
    "birthday": "2009-03-20",
    "number_sets": [1, 2]
  }
]
```

---

## Вложенные структуры

Если бэкенд отдаёт категорию и/или сет во вложенных объектах (например, `participant_category.category`, `set.number_set`), нужно при формировании ответа **развернуть** их в плоские поля на верхнем уровне участника:

```json
// Вместо:
{
  "middlename": "Иванов Иван",
  "participant_category": { "category": "1 группа (2011-2010)" },
  "set": { "number_set": 1 }
}

// Нужно (или дополнительно):
{
  "middlename": "Иванов Иван",
  "category": "1 группа (2011-2010)",
  "number_set": 1
}
```

---

## Проверка

1. Убедиться, что в ответе есть поле `category` (строка) и оно совпадает с категориями события.
2. Для соревнований с несколькими сетами — в ответе есть `number_set` или `number_sets` у участников.
3. Проверить структуру ответа в DevTools / Postman: поля на верхнем уровне, а не внутри вложенных объектов (если Flutter не умеет их доставать).
